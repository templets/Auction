var request = require('request');
var sprintf = require('sprintf').sprintf;

// TODO: Is splitting configuration and routes into two parts a good pattern?
module.exports = function(app, clientId, clientSecret, hostBaseUrl,
  callbackUrl) {
  var singly = require('singly')(clientId, clientSecret, callbackUrl);

  // Generate a Singly authorization link
  function authorizationLink(req) {
    var returning = req && req.session && req.session.profiles;

    return function(service, name) {
      if (returning && req.session.profiles[service] !== undefined) {
        return '<span class="check">&#10003;</span> ' + name;
      }

      var options = {
        client_id: clientId,
        redirect_uri: callbackUrl
      };

      // set account to the user's Singly id for profile merging
      // see https://singly.com/docs/authorization
      if (returning && req.session.profiles.id) {
        options.access_token = req.session.accessToken;
      }
      else {
        options.account = 'false';
      }

      var url = singly.getAuthenticateURL(service, options);
      return sprintf('<a href="%s">%s</a>', url, name);
    };
  }

  return {
    configuration: function() {
      // Make the authorizationLink function available to templates; we use a
      // middleware because it depends on the profiles in the user's session.
      app.use(function(req, res, next) {
        res.locals.authorizationLink = authorizationLink(req);
        next();
      });
    },
    routes: function() {
      // This is experimental so you can ignore it, see https://singly.com/write
      app.get('/apiauth', function(req, res) {
        if (!req.session ||
          !req.session.profiles) {
          return res.send("not logged in, temp dead end, TODO", 400);
        }

        res.render('apiauth', {
          callback: req.query.callback,
          account: req.session.profiles.id,
          validation: require('crypto').createHash('md5').update(clientSecret +
            req.session.profiles.id).digest('hex'),
          session: req.session
        });
      });

      app.get('/callback', function(req, res) {
        var code = req.param('code');

        // Exchange the OAuth2 code for an access token
        singly.getAccessToken(code, function(err, accessTokenRes, token) {
          // Save the token for future API requests
          req.session.accessToken = token.access_token;

          // Fetch the user's service profile data
          singly.get('/profiles', { access_token: token.access_token },
            function(err, profiles) {
            req.session.profiles = profiles.body;

            res.redirect(hostBaseUrl + '/');
          });
        });
      });
    }
  };
};
